% kapitel3.tex
\chapter{ Collision Finding}
\label{chapter:kap3}
\section {About collisions }
Hash functions have resistance:
\begin{enumerate}
    \item First Preimage Resistance: for a hash function $h(m) = H$ the massage $m$ is hard to find.       
    \item Second Preimage Resistance: for a given messages $m_1$ it is hard to find an $m_2$ with $m_1 \neq m_2 $ and $h(m_1) = h(m_2)$.
    \item Collision Resistance: two arbitrary messages  $m_1$ and $m_2$ with $\neq m_2 $ and  $h(m_1) = h(m_2)$ are hard to find.
\end{enumerate}


\section{Differential Path}
Stevens starts with Wangs attack, which trys to finde to pairs of blocks:
\( \left(B_0 , B_0' \right) \)  and \( \left(B_1 , B_1' \right) \) that \( IHV = IHV' \),
 with the goal to create two massages $ M $ and $ M' $, with the same hash value:

\begin{align*}
    &IHV_0 &\xrightarrow[M_{(1)}] {}&\cdots &\xrightarrow[M_k]{} &IHV_k \xrightarrow[B_0]{} &IHV_{k + 1}  &\xrightarrow[B_1]{} &IHV_{k + 2}  &\xrightarrow[M_{k+1}]{}&\cdots &\xrightarrow[M_N]{} &IHV_N\\
    &=     &                        &       &                    &=                         &\ne          &                    &=            &                       &       &                    &= \\
    &IHV_0 &\xrightarrow[M_{(1)}] {}&\cdots &\xrightarrow[M_k]{} &IHV_k \xrightarrow[B_0]{} &IHV'_{k + 1} &\xrightarrow[B_1]{} &IHV'_{k + 2} &\xrightarrow[M_{k+1}]{}&\cdots &\xrightarrow[M_N]{} &IHV_N\\
\end{align*} 
The idea to manipulate a block $B$ such that $Q_1 \dots Q_{16}$ maintain their conditions and that $Q_17$ to some $Q_k$ do not change at all. We try to make k as large as possible.
\section{Bit Conditions}
Bit conditions describe the differential path on bits. 
We need the bit conditions to avoid a carry, so a manipulation in step $t$ stays in step $t$ and does not propagate beyond the $31$st bit.
We look at conditions and restrictions. The restrictions leads to conditions, which we calculate in the following.
A restriction e.g. $\Delta T_2 \left[\ 31 \right] = +1 $ leads to conditions $ Q_1\left[ 16 \right] Q_2\left[ 16 \right] = Q_3\left[ 15 \right] = 0 $ and $ Q_2[15] = 1$.
Notice, conditions are on $\Delta T_t[i]$ a state in md5-algorithm before the rotation and restrictions are on $Q_t[i]$ states of the md5-algorithm after the rotation.\\ 
We calculate the bit conditions by using the Add-Difference for two massage blocks containing tow blocks $N|M$ and $N'|M'$. The XOR-Difference is useful, too.
\begin{align*}
    \delta X &= X' - X \left( mod32 \right) \text{ Add-Difference}\\
    \Delta X &= X' \oplus X \text{ XOR-Difference}\\
    \lambda \left[i\right] &= \text{ our guess for the ith bit: } X\left[i\right] \\
    \\
    \text{if } \Delta X = \lambda &\Rightarrow \delta x \text{ can be determined}
\end{align*}
For $\lambda \left[i\right]$ we only need to consider $i < 31$, since $X \left[ 31 \right]$ as msb always creates a add difference of $2^{31}$.\\
\begin{wrapfigure}[]{r}{0.2\textwidth}
    %\caption*{\textcolor{red}{fix writing}}
    %\begin{table}[]
        \begin{tabular}{| c | c |}
            \hline
            $t$ & $RC(t)$    \\
            \hline
            \hline
            0  & 7 \\
            1  & 12 \\
            2  & 17 \\
            3  & 22 \\
            4  & 7 \\
            5  & 12 \\
            6  & 17 \\
            7  & 22 \\
            8  & 7 \\
            9  & 12 \\
            10 & 17 \\
            11 & 22 \\
            12 & 7 \\
            13 & 12 \\
            14 & 17 \\
            15 & 22 \\
            \hline
        \end{tabular}
        \label{RC}
    %\end{table}
    \end{wrapfigure}
We calculate a $\delta$ for each $f_t$, $Q_t$, $T_t$ and $R_t$ for our add difference, to calculate $Q_{t+1}$ .
Additional we need the rotation constant $RC$ for each $t$. 
In general we begin with the $f_t$ since we want $f_t$ to be in a particular state.
Since we want to avoid a carries in our calculation 


\begin{align*}
    \delta F_t &= f \left( Q'_t,Q'_{t-1},Q'_{t-2} \right) \\
    \delta T_t &= \delta F_t + \delta  Q'_{t-3} + \delta W_t \\
    \delta R_t &=  RL \left(T'_t,RC_t \right) - RL \left(T_t,RC_t \right)\\
    \delta Q_{t+1} &= \delta Q_t + \delta R_t
\end{align*}


\begin{enumerate}
    \item $t \in \{0,1,2,3\}$:\\
     $Q_t = 0 $ since here is no influence by an message and no calculation of f, there is nothing to change:
    \item $t = 4$\\
    $\Delta T_4 = -2^{31}$, because we must not have a carry, we \textit{lock} the last bit.
    Since  $RL(T_4, RC_4) = RL(-2^{31}, 7) = -2^6 $ and $\delta Q_4 = 0 \Rightarrow  \delta Q_5 = -2^6$  
\end{enumerate}

\section{About Code}
The first 16 Qs can be choosen abretary, as long as we fullfill the conditions.\\
Stevens does this by generating really good ramdom values.
After this he alters the random values so thy fullfill conditions.
We follow Stevens appoache but genereate "normal" random vlaues and alter these so they fullfill the condidtions
Improvement for rng is possible. \\
Example for Stevens bit manipulation for $Q_t$ mit $t = 3$ :\\
Bit condition for $Q_t | t =3$ :\\
\\
$1.$ the val to set the zeros (and with 0xfe87bc3f)\\
$2.$ the val to set the ones ( or with $0x017841c0$)\\
$3.$ the new bit Conds\\
$4.$ the old bit Conds



\begin{align*}    
    1.& \& & 11111110 & & 10000111 & & 10111100 & & 00111111 & & 0xfe87bc3f \\
    2.& \| & 00000001 & & 01111000 & & 01000001 & & 11000000 & & 0x017841c0 \\
    3.&    & ........ & & .1111... & & .1....01 & & 11...... & &  \\
    4.&    & ........ & & ....0... & & ....0... & & .0...... & &  
\end{align*}

  the $\&$ flips the $0$ correct, the $\|$ flips the $1$ correct
\newpage


\begin{align*}
    m_t = RR \left( Q_{t+1} - Q_t , RC_t\right) - f_t \left( Q_t, Q_{t-1}, Q_{t-2} \right) - Q_{t-3} - AC
\end{align*}

